// std.fire created on 2019-10-14 as part of xcikit project
// https://github.com/rbrich/xcikit
//
// Copyright 2019â€“2021 Radek Brich
// Licensed under the Apache License, Version 2.0 (see LICENSE file)


// Logical operators

class LogicalNot T  { not :   T -> Bool }
class LogicalOr  T  { or  : T T -> Bool }
class LogicalAnd T  { and : T T -> Bool }

instance LogicalNot Bool { not = { __logical_not } }
instance LogicalOr  Bool { or  = { __logical_or  } }
instance LogicalAnd Bool { and = { __logical_and } }


// Bitwise operators

class BitwiseNot T  { bit_not :   T -> T }
class BitwiseOr  T  { bit_or  : T T -> T }
class BitwiseAnd T  { bit_and : T T -> T }
class BitwiseXor T  { bit_xor : T T -> T }
class ShiftLeft  T  { shift_left  : T T -> T }
class ShiftRight T  { shift_right : T T -> T }

instance BitwiseNot Byte  { bit_not = { __bitwise_not_8  } }
instance BitwiseNot Int32 { bit_not = { __bitwise_not_32 } }
instance BitwiseNot Int64 { bit_not = { __bitwise_not_64 } }
instance BitwiseOr  Byte  { bit_or  = { __bitwise_or_8   } }
instance BitwiseOr  Int32 { bit_or  = { __bitwise_or_32  } }
instance BitwiseOr  Int64 { bit_or  = { __bitwise_or_64  } }
instance BitwiseAnd Byte  { bit_and = { __bitwise_and_8  } }
instance BitwiseAnd Int32 { bit_and = { __bitwise_and_32 } }
instance BitwiseAnd Int64 { bit_and = { __bitwise_and_64 } }
instance BitwiseXor Byte  { bit_xor = { __bitwise_xor_8  } }
instance BitwiseXor Int32 { bit_xor = { __bitwise_xor_32 } }
instance BitwiseXor Int64 { bit_xor = { __bitwise_xor_64 } }
instance ShiftLeft  Byte  { shift_left  = { __shift_left_8   } }
instance ShiftLeft  Int32 { shift_left  = { __shift_left_32  } }
instance ShiftLeft  Int64 { shift_left  = { __shift_left_64  } }
instance ShiftRight Byte  { shift_right = { __shift_right_8  } }
instance ShiftRight Int32 { shift_right = { __shift_right_32 } }
instance ShiftRight Int64 { shift_right = { __shift_right_64 } }


// Arithmetic operators

class Neg T  { neg : T -> T }
class Add T  { add : T T -> T }
class Sub T  { sub : T T -> T }
class Mul T  { mul : T T -> T }
class Div T  { div : T T -> T }
class Mod T  { mod : T T -> T }
class Exp T  { exp : T T -> T }

instance Neg Byte  { neg = { __neg 0x11 } }
instance Neg Int32 { neg = { __neg 0x88 } }
instance Neg Int64 { neg = { __neg 0x99 } }
instance Neg Float32 { neg = { __neg 0xCC } }
instance Neg Float64 { neg = { __neg 0xDD } }
instance Add Byte  { add = { __add 0x11 } }
instance Add Int32 { add = { __add 0x88 } }
instance Add Int64 { add = { __add 0x99 } }
instance Add Float32 { add = { __add 0xCC } }
instance Add Float64 { add = { __add 0xDD } }
instance Sub Byte  { sub = { __sub 0x11 } }
instance Sub Int32 { sub = { __sub 0x88 } }
instance Sub Int64 { sub = { __sub 0x99 } }
instance Sub Float32 { sub = { __sub 0xCC } }
instance Sub Float64 { sub = { __sub 0xDD } }
instance Mul Byte  { mul = { __mul 0x11 } }
instance Mul Int32 { mul = { __mul 0x88 } }
instance Mul Int64 { mul = { __mul 0x99 } }
instance Mul Float32 { mul = { __mul 0xCC } }
instance Mul Float64 { mul = { __mul 0xDD } }
instance Div Byte  { div = { __div 0x11 } }
instance Div Int32 { div = { __div 0x88 } }
instance Div Int64 { div = { __div 0x99 } }
instance Div Float32 { div = { __div 0xCC } }
instance Div Float64 { div = { __div 0xDD } }
instance Mod Byte  { mod = { __mod 0x11 } }
instance Mod Int32 { mod = { __mod 0x88 } }
instance Mod Int64 { mod = { __mod 0x99 } }
instance Exp Byte  { exp = { __exp 0x11 } }
instance Exp Int32 { exp = { __exp 0x88 } }
instance Exp Int64 { exp = { __exp 0x99 } }
instance Exp Float32 { exp = { __exp 0xCC } }
instance Exp Float64 { exp = { __exp 0xDD } }


// Comparison operators

class Eq T {
    eq : T T -> Bool
    ne : T T -> Bool // = fun x y { not (eq x y) };
}

class Ord T (Eq T) {
    lt : T T -> Bool
    gt : T T -> Bool
    le : T T -> Bool
    ge : T T -> Bool
}


instance Eq Bool {
    eq = { __equal_8 }
    ne = { __not_equal_8 }
}

instance Eq Byte {
    eq = { __equal_8 }
    ne = { __not_equal_8 }
}

instance Eq Char {
    eq = { __equal_32 }
    ne = { __not_equal_32 }
}

instance Eq Int32 {
    eq = { __equal_32 }
    ne = { __not_equal_32 }
}

instance Eq Int64 {
    eq = { __equal_64 }
    ne = { __not_equal_64 }
}

instance Eq Float32 {
    eq = { __equal_32 }
    ne = { __not_equal_32 }
}

instance Eq Float64 {
    eq = { __equal_64 }
    ne = { __not_equal_64 }
}

/*
instance Eq [T] ( Eq T ) {
    eq = fun x y {
        match x, y {
            [], [] -> true
            [], [...] -> false
            [...], [] -> false
            [x1, xrest...], [y1, yrest...] -> (eq x1 y1) && (eq xrest yrest)
        }
    }
}
*/


instance Ord Byte {
    lt = { __less_than_8 }
    gt = { __greater_than_8 }
    le = { __less_equal_8 }
    ge = { __greater_equal_8 }
}

instance Ord Char {
    lt = { __less_than_32 }
    gt = { __greater_than_32 }
    le = { __less_equal_32 }
    ge = { __greater_equal_32 }
}

instance Ord Int32 {
    lt = { __less_than_32 }
    gt = { __greater_than_32 }
    le = { __less_equal_32 }
    ge = { __greater_equal_32 }
}

instance Ord Int64 {
    lt = { __less_than_64 }
    gt = { __greater_than_64 }
    le = { __less_equal_64 }
    ge = { __greater_equal_64 }
}

instance Ord Float32 {
    lt = { __less_than_32 }
    gt = { __greater_than_32 }
    le = { __less_equal_32 }
    ge = { __greater_equal_32 }
}

instance Ord Float64 {
    lt = { __less_than_64 }
    gt = { __greater_than_64 }
    le = { __less_equal_64 }
    ge = { __greater_equal_64 }
}

/*
// TODO: document type args `<T>`, constraints `<Ord T>`, attributes `lazy`
f : <T> T T -> T with (Ord T) = fun x y { x < y }
f : <Ord T> T T -> T = fun x y { x < y }
f = lazy fun<Ord T> x:T y:T -> T { x < y }
f = fun <T, I> l:[T] i:I -> T { l ! i }

// Unify syntax of functions and classes?
// The angle brackets would be only decoration, not needed syntactically.
class Eq <T> { }
class Ord <T> (Eq T) { }
*/


class Cast T R {
    cast : T -> R
}

// Note: Cast to Void is handled by the compiler, instances with R=Void are ignored.

instance Cast Bool Byte { cast = { __noop } }
instance Cast Bool Int32 { cast = { __cast 0x18 } }
instance Cast Bool Int64 { cast = { __cast 0x19 } }

instance Cast Byte Bool { cast = fun x { x != b'\0' } }
instance Cast Byte Int32 { cast = { __cast 0x18 } }
instance Cast Byte Int64 { cast = { __cast 0x19 } }

instance Cast Int32 Bool { cast = fun x { x != 0 } }
instance Cast Int32 Byte { cast = { __cast 0x81 } }
instance Cast Int32 Int64 { cast = { __cast 0x89 } }
instance Cast Int32 Float32 { cast = { __cast 0x8c } }
instance Cast Int32 Float64 { cast = { __cast 0x8d } }

instance Cast Int64 Bool { cast = fun x { x != 0L } }
instance Cast Int64 Byte { cast = { __cast 0x91 } }
instance Cast Int64 Int32 { cast = { __cast 0x98 } }
instance Cast Int64 Float32 { cast = { __cast 0x9C } }
instance Cast Int64 Float64 { cast = { __cast 0x9D } }

instance Cast Float32 Int32 { cast = { __cast 0xC8 } }
instance Cast Float32 Int64 { cast = { __cast 0xC9 } }
instance Cast Float32 Float64 { cast = { __cast 0xCD } }

instance Cast Float64 Int32 { cast = { __cast 0xD8 } }
instance Cast Float64 Int64 { cast = { __cast 0xD9 } }
instance Cast Float64 Float32 { cast = { __cast 0xDC } }

succ = fun<T> x:T -> T { x + 1 }
pred = fun<T> x:T -> T { x - 1 }
max = fun<T> x:T y:T -> T { if x > y then x else y }


subscript = fun<T> [T] Int -> T { __subscript __type_id<T> }

//filter = fun<Ord T> fn [T] -> [T] { }
//map = fun<T> fn l:[T] -> [T] { (fn l[0]) + l[1:] }
//reduce = fun<Ord T> fn [T] -> T { }
//sum = reduce add

//sort = fun<Ord T> [T] -> [T] { __sort __type_id<T> }
