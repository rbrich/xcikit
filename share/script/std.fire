// std.fire created on 2019-10-14 as part of xcikit project
// https://github.com/rbrich/xcikit
//
// Copyright 2019, 2020 Radek Brich
// Licensed under the Apache License, Version 2.0 (see LICENSE file)

class Eq T {
    eq : T T -> Bool
    ne : T T -> Bool // = fun x y { not (eq x y) };
}

class Ord T (Eq T) {
    lt : T T -> Bool
    gt : T T -> Bool
    le : T T -> Bool
    ge : T T -> Bool
}


instance Eq Bool {
    eq = { __equal_8 }
    ne = { __not_equal_8 }
}

instance Eq Byte {
    eq = { __equal_8 }
    ne = { __not_equal_8 }
}

instance Eq Char {
    eq = { __equal_32 }
    ne = { __not_equal_32 }
}

instance Eq Int32 {
    eq = { __equal_32 }
    ne = { __not_equal_32 }
}

instance Eq Int64 {
    eq = { __equal_64 }
    ne = { __not_equal_64 }
}

instance Eq Float32 {
    eq = { __equal_32 }
    ne = { __not_equal_32 }
}

instance Eq Float64 {
    eq = { __equal_64 }
    ne = { __not_equal_64 }
}

/*
instance Eq [T] ( Eq T ) {
    eq = fun x y {
        match x, y {
            [], [] -> true
            [], [...] -> false
            [...], [] -> false
            [x1, xrest...], [y1, yrest...] -> (eq x1 y1) && (eq xrest yrest)
        }
    }
}
*/


instance Ord Byte {
    lt = { __less_than_8 }
    gt = { __greater_than_8 }
    le = { __less_equal_8 }
    ge = { __greater_equal_8 }
}

instance Ord Char {
    lt = { __less_than_32 }
    gt = { __greater_than_32 }
    le = { __less_equal_32 }
    ge = { __greater_equal_32 }
}

instance Ord Int32 {
    lt = { __less_than_32 }
    gt = { __greater_than_32 }
    le = { __less_equal_32 }
    ge = { __greater_equal_32 }
}

instance Ord Int64 {
    lt = { __less_than_64 }
    gt = { __greater_than_64 }
    le = { __less_equal_64 }
    ge = { __greater_equal_64 }
}

instance Ord Float32 {
    lt = { __less_than_32 }
    gt = { __greater_than_32 }
    le = { __less_equal_32 }
    ge = { __greater_equal_32 }
}

instance Ord Float64 {
    lt = { __less_than_64 }
    gt = { __greater_than_64 }
    le = { __less_equal_64 }
    ge = { __greater_equal_64 }
}

/*
f : fun T T -> T with (Ord T) = |x y| { x < y }
f = fun x:T y:T -> T lazy with (Ord T) { x < y }
*/


class Cast T R {
    cast : T -> R
}

// Note: Cast to Void is handled by the compiler, instances with R=Void are ignored.

instance Cast Bool Byte { cast = { __noop } }
instance Cast Bool Int32 { cast = { __cast 0x18 } }
instance Cast Bool Int64 { cast = { __cast 0x19 } }

instance Cast Byte Bool { cast = fun x { x != b'\0' } }
instance Cast Byte Int32 { cast = { __cast 0x18 } }
instance Cast Byte Int64 { cast = { __cast 0x19 } }

instance Cast Int32 Bool { cast = fun x { x != 0 } }
instance Cast Int32 Byte { cast = { __cast 0x81 } }
instance Cast Int32 Int64 { cast = { __cast 0x89 } }
instance Cast Int32 Float32 { cast = { __cast 0x8c } }
instance Cast Int32 Float64 { cast = { __cast 0x8d } }

instance Cast Int64 Bool { cast = fun x { x != 0L } }
instance Cast Int64 Byte { cast = { __cast 0x91 } }
instance Cast Int64 Int32 { cast = { __cast 0x98 } }
instance Cast Int64 Float32 { cast = { __cast 0x9C } }
instance Cast Int64 Float64 { cast = { __cast 0x9D } }

instance Cast Float32 Int32 { cast = { __cast 0xC8 } }
instance Cast Float32 Int64 { cast = { __cast 0xC9 } }
instance Cast Float32 Float64 { cast = { __cast 0xCD } }

instance Cast Float64 Int32 { cast = { __cast 0xD8 } }
instance Cast Float64 Int64 { cast = { __cast 0xD9 } }
instance Cast Float64 Float32 { cast = { __cast 0xDC } }

succ = fun x { x + 1 }
pred = fun x { x - 1 }
max = fun x y { if x > y then x else y }
